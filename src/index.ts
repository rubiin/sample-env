#! /usr/bin/env node

import fs from "node:fs";
import { homedir } from "node:os";
import readline from "node:readline";
import yargs from "yargs/yargs";
import { hideBin } from "yargs/helpers";
import packageJson from "../package.json";
import { splitLine } from "./utils";

interface Options {
  env?: string;
  sample?: string;
  banner?: string;
  prefix?: string;
  removeComments?: boolean;
}

const defaultEnvironmentPath = `${homedir()}/.sample-env.rc`;

const writeCongfigFile = (data: Options) => {
  return fs.writeFileSync(
    defaultEnvironmentPath,
    JSON.stringify(data, undefined, 2),
  );
};

const readCongfigFile = () => {
  if (!fs.existsSync(defaultEnvironmentPath)) {
    const defaultConfig = {
      env: ".env",
      sample: ".env.sample",
      banner: "# This is a sample file generated by sample-env",
      removeComments: false,
    } as Options;

    writeCongfigFile(defaultConfig);

    return defaultConfig;
  }
  const config = fs.readFileSync(defaultEnvironmentPath, "utf8");

  return JSON.parse(config) as Options;
};

const allArguments = yargs(hideBin(process.argv))
  .usage("Usage: $0 [options]")
  .help("help")
  .alias("help", "h")
  .version("version", packageJson.version)
  .alias("version", "v")
  .showHelpOnFail(true, "whoops, something went wrong! run with --help")
  .command({
    command: "*",
    handler() {
      yargs().showHelp();
    },
  })
  .options({
    env: {
      description: "<filename> input file name",
      requiresArg: true,
      required: false,
    },
    sample: {
      description: "<filename> output file name",
      requiresArg: true,
      required: false,
    },
    banner: {
      description: "add banner to output file",
      requiresArg: true,
      required: false,
      alias: "b",
    },
    removeComments: {
      description: "removes comment from output file",
      requiresArg: false,
      required: false,
      boolean: true,
      alias: "r",
    },
    prefix: {
      description:
        "List of string prefixes to use only certain env variables, could be an empty string to use all available variables.",
      requiresArg: true,
      required: false,
      alias: "p",
    },
  }).argv as Options;

export const main = () => {
  const configFile = readCongfigFile();

  const environmentPath = allArguments.env ?? configFile.env;
  const samplePath = allArguments.sample ?? configFile.sample;
  const fileStream = fs.createWriteStream(samplePath);
  const banner = allArguments.banner ?? configFile.banner;
  const removeComments
    = allArguments.removeComments ?? configFile.removeComments;
  const prefix = allArguments.prefix ?? configFile.prefix;

  const reader = readline.createInterface({
    input: fs.createReadStream(environmentPath),
    crlfDelay: Number.POSITIVE_INFINITY,
  });

  if (banner) fileStream.write(`${banner}\n`);

  reader.on("line", (line) => {
    if ((line.length === 0 && !prefix) || (line.startsWith("#") && removeComments)) {
      fileStream.write("\n");
    }
    else {
      if (prefix && !line.startsWith(prefix)) return;
      fileStream.write(`${splitLine(line)}\n`);
    }
  });

  console.debug(
    "\u001B[32m%s\u001B[0m",
    `âœ… Successfully generated file ${samplePath}`,
  );
};

main();
