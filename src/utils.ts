import readline from "node:readline";
import path from "node:path";

import fs from "node:fs";
import process from "node:process";
import { homedir } from "node:os";
import chalk from "chalk";
import type { Options } from "index";

export const defaultEnvironmentPath = `${homedir()}/.envrc`;

export const defaultConfig: Options = {
  env: ".env",
  sample: ".env.sample",
  banner: "# This is a sample file generated by sample-env",
  removeComments: false,
};

export const splitLine = (line: string) => {
  const result = line.split("=");

  if (result.length === 1)
    return result[0];
  return `${result[0]}=`;
};

export const readCongfigFile = (): Options => {
  if (!fs.existsSync(defaultEnvironmentPath)) {
    fs.writeFileSync(
      defaultEnvironmentPath,
      JSON.stringify(defaultConfig, undefined, 2),
    );

    return defaultConfig;
  }
  const config = fs.readFileSync(path.resolve(defaultEnvironmentPath), "utf8");

  return JSON.parse(config) as Options;
};

export const writeSampleFile = (allArguments: Options) => {
  const configFile = readCongfigFile();
  const environmentPath = path.resolve(allArguments.env ?? configFile.env);
  if (!fs.existsSync(environmentPath)) {
    console.error(
      chalk.red(`❌ Config file not found at path: ${environmentPath}!`),
    );
    // eslint-disable-next-line unicorn/no-process-exit
    process.exit(0);
  }

  const samplePath = path.resolve(allArguments.sample ?? configFile.sample);
  const banner = allArguments.banner ?? configFile.banner;
  const removeComments
  = allArguments.removeComments ?? configFile.removeComments;
  const prefix = allArguments?.prefix;
  const fileStream = fs.createWriteStream(samplePath);

  // convert comma separated prefix to array
  const prefixArray
    = prefix && typeof prefix === "string" && prefix.includes(",")
      ? prefix.split(",")
      : prefix;

  const reader = readline.createInterface({
    input: fs.createReadStream(path.resolve(environmentPath)),
    crlfDelay: Number.POSITIVE_INFINITY,
  });

  if (banner) fileStream.write(`${banner}\n`);

  // Check prefix array once outside the event listener
  const shouldIgnoreLine = prefix && Array.isArray(prefixArray);
  let shouldWriteLine = true;

  reader.on("line", (line) => {
    const isEmptyLine = line.length === 0;
    const isCommentLine = line.startsWith("#");

    if ((isCommentLine && removeComments) || (isEmptyLine && !prefix)) shouldWriteLine = false;
    else if (
      shouldIgnoreLine
      && prefixArray.some(element => line.startsWith(element.trim()))
    )
      shouldWriteLine = false;

    if (shouldWriteLine) fileStream.write(`${splitLine(line)}\n`);
    else fileStream.write(`\n`);
  });

  console.debug(
    chalk.blue("🚀 Successfully generated file at:")
      + chalk.green(` ${samplePath}`),
  );
};
